/*	File:  fftPlatformConf.cpp

	Description:
		Platform-dependent configuration support for MatrixFFT library.
	
	Copyright:
		Copyright (C) 2009 Apple Inc.  All rights reserved.
	
	Disclaimer:
		IMPORTANT:  This Apple software is supplied to you by Apple
		Computer, Inc. ("Apple") in consideration of your agreement to
		the following terms, and your use, installation, modification
		or redistribution of this Apple software constitutes acceptance
		of these terms.  If you do not agree with these terms, please
		do not use, install, modify or redistribute this Apple
		software.

		In consideration of your agreement to abide by the following
		terms, and subject to these terms, Apple grants you a personal,
		non-exclusive license, under Appleâ€™s copyrights in this
		original Apple software (the "Apple Software"), to use,
		reproduce, modify and redistribute the Apple Software, with or
		without modifications, in source and/or binary forms; provided
		that if you redistribute the Apple Software in its entirety and
		without modifications, you must retain this notice and the
		following text and disclaimers in all such redistributions of
		the Apple Software.  Neither the name, trademarks, service
		marks or logos of Apple Computer, Inc. may be used to endorse
		or promote products derived from the Apple Software without
		specific prior written permission from Apple.  Except as
		expressly stated in this notice, no other rights or licenses,
		express or implied, are granted by Apple herein, including but
		not limited to any patent rights that may be infringed by your
		derivative works or by other works in which the Apple Software
		may be incorporated.

		The Apple Software is provided by Apple on an "AS IS" basis.
		APPLE MAKES NO WARRANTIES, EXPRESS OR IMPLIED, INCLUDING
		WITHOUT LIMITATION THE IMPLIED WARRANTIES OF NON-INFRINGEMENT,
		MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE, REGARDING
		THE APPLE SOFTWARE OR ITS USE AND OPERATION ALONE OR IN
		COMBINATION WITH YOUR PRODUCTS.

		IN NO EVENT SHALL APPLE BE LIABLE FOR ANY SPECIAL, INDIRECT,
		INCIDENTAL OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
		TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
		DATA, OR PROFITS; OR BUSINESS INTERRUPTION) ARISING IN ANY WAY
		OUT OF THE USE, REPRODUCTION, MODIFICATION AND/OR DISTRIBUTION
		OF THE APPLE SOFTWARE, HOWEVER CAUSED AND WHETHER UNDER THEORY
		OF CONTRACT, TORT (INCLUDING NEGLIGENCE), STRICT LIABILITY OR
		OTHERWISE, EVEN IF APPLE HAS BEEN ADVISED OF THE POSSIBILITY OF
		SUCH DAMAGE.
*/

/*
 * fftPlatformConf.cpp - Platform-dependent configuration support for MatrixFFT library.
 *			  
 * Created 11/05/2009. 
 * Copyright 2009 by Apple, Inc. 
 */

#include "fftPlatformConf.h"
#include "fftPriv.h"
#include <libMatrixFFT/MatrixFFT.h>

#pragma mark ---- Machine-generated platform-specific configuration parameters ----

/***
 *** These tables were generated by the mfftAutoConf program.
 ***/
 
#ifndef FFT_PLATFORM
#error Please define FFT_PLATFORM in fftPlatformConf.h.
#endif

#if     (FFT_PLATFORM == FFT_Nehalem_8_32GB)

#pragma mark --- 8-core Nehalem with 32 GB RAM ---

/*
 * CPU                     : Intel(R) Xeon(R) CPU X5570 @ 2.93GHz
 * RAM                     : 32GB
 * Physical CPUs           : 8
 * Logical CPUs            : 16
 * L1 data cache size      : 32768
 * L2 cache size           : 262144
 * L3 cache size           : 8388608
 * L1 processors per cache : 2
 * L2 processors per cache : 2
 * L3 processors per cache : 8
 */
   #if   ((FFT_DOUBLE_PREC == 0) && (FFT_SPLIT_COMPLEX == 0))

      /* Single precision Interleaved complex */

      #define CONFIG_TABLE_1D_REAL_START   7   /* log2(n) of first entry of 1-D real table */
      #define CONFIG_TABLE_1D_REAL_END    32   /* log2(n) of last  entry of 1-D real table */
      #define CONFIG_TABLE_2D_REAL_START   3   /* log2(n) of first entry of 2-D real table */
      #define CONFIG_TABLE_2D_REAL_END    16   /* log2(n) of last  entry of 2-D real table */
      #define CONFIG_TABLE_1D_CMPL_START   6   /* log2(n) of first entry of 1-D complex table */
      #define CONFIG_TABLE_1D_CMPL_END    31   /* log2(n) of last  entry of 1-D complex table */
      #define CONFIG_TABLE_2D_CMPL_START   2   /* log2(n) of first entry of 2-D complex table */
      #define CONFIG_TABLE_2D_CMPL_END    15   /* log2(n) of last  entry of 2-D complex table */

      static int mfftRectOffsetTable[] = 
             { -1, -1, -1, -1, 1, 2, 1, 1, 1, -1, -2, -1, -2, -2, -2, -2, -1, -1, 0, 1, 0, 0, 0, 0, -1, 0};

      static size_t fftStripeSize1DComplex[] = 
             { 11, 2, 14, 64, 32, 16, 64, 56, 10, 11, 7, 12, 10, 12, 7, 12, 8, 16, 16, 8, 8, 8, 48, 48, 56, 56};
      static size_t fftStripeSize2DComplex[] = 
             { 11, 9, 5, 64, 16, 13, 2, 4, 10, 8, 8, 8, 8, 40};
      static size_t fftStripeSize2DReal[] = 
             { 6, 15, 13, 48, 16, 14, 4, 7, 8, 8, 64, 48, 40, 40};
             
      #define MFFT_1D_COMPLEX_MIN_SIZE    15
      #define MFFT_2D_COMPLEX_MIN_SIZE    15
      #define MFFT_1D_REAL_MIN_SIZE       16
      #define MFFT_2D_REAL_MIN_SIZE       15

   #endif   /* ((FFT_DOUBLE_PREC == 0) && (FFT_SPLIT_COMPLEX == 0)) */

   #if   ((FFT_DOUBLE_PREC == 0) && (FFT_SPLIT_COMPLEX == 1))

      /* Single precision Split complex */

      #define CONFIG_TABLE_1D_REAL_START   7   /* log2(n) of first entry of 1-D real table */
      #define CONFIG_TABLE_1D_REAL_END    32   /* log2(n) of last  entry of 1-D real table */
      #define CONFIG_TABLE_2D_REAL_START   3   /* log2(n) of first entry of 2-D real table */
      #define CONFIG_TABLE_2D_REAL_END    16   /* log2(n) of last  entry of 2-D real table */
      #define CONFIG_TABLE_1D_CMPL_START   6   /* log2(n) of first entry of 1-D complex table */
      #define CONFIG_TABLE_1D_CMPL_END    31   /* log2(n) of last  entry of 1-D complex table */
      #define CONFIG_TABLE_2D_CMPL_START   2   /* log2(n) of first entry of 2-D complex table */
      #define CONFIG_TABLE_2D_CMPL_END    15   /* log2(n) of last  entry of 2-D complex table */

      static int mfftRectOffsetTable[] = 
             { -1, -1, -2, -1, -2, 1, 0, 1, 0, -1, -1, 0, -2, -1, -3, -2, -3, -2, -1, 0, -1, 0, 0, 1, 1, 0};

      static size_t fftStripeSize1DComplex[] = 
             { 7, 128, 13, 2, 64, 112, 32, 96, 112, 16, 16, 16, 32, 32, 32, 16, 16, 64, 32, 16, 16, 64, 112, 112, 80, 112};
      static size_t fftStripeSize2DComplex[] = 
             { 12, 6, 112, 64, 48, 128, 32, 32, 16, 16, 16, 16, 80, 80};
      static size_t fftStripeSize2DReal[] = 
             { 112, 16, 80, 8, 128, 64, 48, 16, 32, 16, 16, 112, 96, 48};
             
      #define MFFT_1D_COMPLEX_MIN_SIZE    15
      #define MFFT_2D_COMPLEX_MIN_SIZE    15
      #define MFFT_1D_REAL_MIN_SIZE       16
      #define MFFT_2D_REAL_MIN_SIZE       16

   #endif   /* ((FFT_DOUBLE_PREC == 0) && (FFT_SPLIT_COMPLEX == 1)) */

   #if   ((FFT_DOUBLE_PREC == 1) && (FFT_SPLIT_COMPLEX == 0))

      /* Double precision Interleaved complex */

      #define CONFIG_TABLE_1D_REAL_START   7   /* log2(n) of first entry of 1-D real table */
      #define CONFIG_TABLE_1D_REAL_END    31   /* log2(n) of last  entry of 1-D real table */
      #define CONFIG_TABLE_2D_REAL_START   3   /* log2(n) of first entry of 2-D real table */
      #define CONFIG_TABLE_2D_REAL_END    15   /* log2(n) of last  entry of 2-D real table */
      #define CONFIG_TABLE_1D_CMPL_START   6   /* log2(n) of first entry of 1-D complex table */
      #define CONFIG_TABLE_1D_CMPL_END    30   /* log2(n) of last  entry of 1-D complex table */
      #define CONFIG_TABLE_2D_CMPL_START   2   /* log2(n) of first entry of 2-D complex table */
      #define CONFIG_TABLE_2D_CMPL_END    14   /* log2(n) of last  entry of 2-D complex table */

      static int mfftRectOffsetTable[] = 
             { -1, 0, -1, -2, -3, -3, -4, -3, -2, -1, -2, -1, -2, -2, -2, 0, -1, 0, 0, 0, 0, 0, -1, 0, 0};

      static size_t fftStripeSize1DComplex[] = 
             { 32, 14, 12, 4, 9, 13, 9, 9, 5, 6, 10, 6, 6, 14, 6, 4, 4, 8, 8, 8, 4, 8, 8, 28, 28};
      static size_t fftStripeSize2DComplex[] = 
             { 14, 15, 2, 7, 12, 15, 2, 9, 5, 4, 8, 4, 32};
      static size_t fftStripeSize2DReal[] = 
             { 3, 7, 13, 24, 24, 2, 10, 6, 4, 8, 13, 16, 14};
             
      #define MFFT_1D_COMPLEX_MIN_SIZE    14
      #define MFFT_2D_COMPLEX_MIN_SIZE    13
      #define MFFT_1D_REAL_MIN_SIZE       15
      #define MFFT_2D_REAL_MIN_SIZE       13

   #endif   /* ((FFT_DOUBLE_PREC == 1) && (FFT_SPLIT_COMPLEX == 0)) */

   #if   ((FFT_DOUBLE_PREC == 1) && (FFT_SPLIT_COMPLEX == 1))

      /* Double precision Split complex */

      #define CONFIG_TABLE_1D_REAL_START   7   /* log2(n) of first entry of 1-D real table */
      #define CONFIG_TABLE_1D_REAL_END    31   /* log2(n) of last  entry of 1-D real table */
      #define CONFIG_TABLE_2D_REAL_START   3   /* log2(n) of first entry of 2-D real table */
      #define CONFIG_TABLE_2D_REAL_END    15   /* log2(n) of last  entry of 2-D real table */
      #define CONFIG_TABLE_1D_CMPL_START   6   /* log2(n) of first entry of 1-D complex table */
      #define CONFIG_TABLE_1D_CMPL_END    30   /* log2(n) of last  entry of 1-D complex table */
      #define CONFIG_TABLE_2D_CMPL_START   2   /* log2(n) of first entry of 2-D complex table */
      #define CONFIG_TABLE_2D_CMPL_END    14   /* log2(n) of last  entry of 2-D complex table */

      static int mfftRectOffsetTable[] = 
             { -2, -1, -1, -1, -4, -3, -4, 1, -3, -2, -2, -2, -2, -2, -2, -2, -1, 0, -1, 0, -1, 1, 1, 0, 0};

      static size_t fftStripeSize1DComplex[] = 
             { 15, 8, 8, 4, 13, 24, 10, 10, 4, 14, 12, 12, 13, 13, 16, 16, 8, 16, 16, 8, 8, 56, 40, 56, 40};
      static size_t fftStripeSize2DComplex[] = 
             { 13, 4, 10, 15, 48, 10, 12, 7, 8, 8, 8, 8, 56};
      static size_t fftStripeSize2DReal[] = 
             { 14, 12, 24, 32, 16, 24, 7, 8, 8, 8, 13, 11, 9};

      #define MFFT_1D_COMPLEX_MIN_SIZE    14
      #define MFFT_2D_COMPLEX_MIN_SIZE    12
      #define MFFT_1D_REAL_MIN_SIZE       15
      #define MFFT_2D_REAL_MIN_SIZE       14
      
   #endif   /* ((FFT_DOUBLE_PREC == 1) && (FFT_SPLIT_COMPLEX == 1)) */


#elif   (FFT_PLATFORM == FFT_Xeon_4_4GB) 

#pragma mark --- 4-core Xeon with 4 GB RAM ---

/*
 * CPU                     : Intel(R) Xeon(R) CPU 5150 @ 2.66GHz
 * RAM                     : 4GB
 * Physical CPUs           : 4
 * Logical  CPUs           : 4
 * L1 data cache size      : 32768
 * L2 cache size           : 4194304
 * L1 processors per cache : 1
 * L2 processors per cache : 2
 */

   #if   ((FFT_DOUBLE_PREC == 0) && (FFT_SPLIT_COMPLEX == 0))

      /* Single precision Interleaved complex */

      #define CONFIG_TABLE_1D_REAL_START   7   /* log2(n) of first entry of 1-D real table */
      #define CONFIG_TABLE_1D_REAL_END    29   /* log2(n) of last  entry of 1-D real table */
      #define CONFIG_TABLE_2D_REAL_START   3   /* log2(n) of first entry of 2-D real table */
      #define CONFIG_TABLE_2D_REAL_END    14   /* log2(n) of last  entry of 2-D real table */
      #define CONFIG_TABLE_1D_CMPL_START   6   /* log2(n) of first entry of 1-D complex table */
      #define CONFIG_TABLE_1D_CMPL_END    28   /* log2(n) of last  entry of 1-D complex table */
      #define CONFIG_TABLE_2D_CMPL_START   2   /* log2(n) of first entry of 2-D complex table */
      #define CONFIG_TABLE_2D_CMPL_END    13   /* log2(n) of last  entry of 2-D complex table */

      static int mfftRectOffsetTable[] = 
             { 1, 0, 0, 0, -1, 2, -2, 0, -3, -1, -4, -2, -1, -1, -2, -1, -3, -2, -2, -1, -1, -1, -2};

      static size_t fftStripeSize1DComplex[] = 
             { 4, 40, 40, 15, 56, 14, 56, 16, 24, 15, 24, 16, 40, 12, 12, 64, 56, 48, 64, 32, 32, 16, 32};
      static size_t fftStripeSize2DComplex[] = 
             { 11, 64, 48, 2, 6, 64, 12, 24, 48, 40, 32, 16};
      static size_t fftStripeSize2DReal[] = 
             { 10, 5, 5, 48, 40, 16, 16, 40, 24, 32, 16, 8};
             
      #define MFFT_1D_COMPLEX_MIN_SIZE    16
      #define MFFT_2D_COMPLEX_MIN_SIZE    16
      #define MFFT_1D_REAL_MIN_SIZE       18
      #define MFFT_2D_REAL_MIN_SIZE       16

   #endif   /* ((FFT_DOUBLE_PREC == 0) && (FFT_SPLIT_COMPLEX == 0)) */


   #if   ((FFT_DOUBLE_PREC == 0) && (FFT_SPLIT_COMPLEX == 1))

      /* Single precision Split complex */

      #define CONFIG_TABLE_1D_REAL_START   7   /* log2(n) of first entry of 1-D real table */
      #define CONFIG_TABLE_1D_REAL_END    29   /* log2(n) of last  entry of 1-D real table */
      #define CONFIG_TABLE_2D_REAL_START   3   /* log2(n) of first entry of 2-D real table */
      #define CONFIG_TABLE_2D_REAL_END    14   /* log2(n) of last  entry of 2-D real table */
      #define CONFIG_TABLE_1D_CMPL_START   6   /* log2(n) of first entry of 1-D complex table */
      #define CONFIG_TABLE_1D_CMPL_END    28   /* log2(n) of last  entry of 1-D complex table */
      #define CONFIG_TABLE_2D_CMPL_START   2   /* log2(n) of first entry of 2-D complex table */
      #define CONFIG_TABLE_2D_CMPL_END    13   /* log2(n) of last  entry of 2-D complex table */

      static int mfftRectOffsetTable[] = 
             { -1, 0, 0, 1, 1, 1, 1, 0, -2, 1, -2, -3, -3, -1, -2, -3, -3, -4, -4, -1, -3, -2, -3};

      static size_t fftStripeSize1DComplex[] = 
             { 64, 32, 9, 128, 80, 48, 48, 32, 16, 16, 64, 48, 32, 128, 48, 64, 32, 64, 32, 32, 32, 32, 32};
      static size_t fftStripeSize2DComplex[] = 
             { 48, 1, 6, 96, 80, 16, 16, 16, 16, 32, 32, 16};
      static size_t fftStripeSize2DReal[] = 
             { 48, 96, 48, 112, 112, 64, 128, 48, 48, 32, 16, 16};
             
      #define MFFT_1D_COMPLEX_MIN_SIZE    17
      #define MFFT_2D_COMPLEX_MIN_SIZE    17
      #define MFFT_1D_REAL_MIN_SIZE       19
      #define MFFT_2D_REAL_MIN_SIZE       16

   #endif   /* ((FFT_DOUBLE_PREC == 0) && (FFT_SPLIT_COMPLEX == 1)) */
   
   #if   ((FFT_DOUBLE_PREC == 1) && (FFT_SPLIT_COMPLEX == 0))

      /* Double precision Interleaved complex */

      #define CONFIG_TABLE_1D_REAL_START   7   /* log2(n) of first entry of 1-D real table */
      #define CONFIG_TABLE_1D_REAL_END    28   /* log2(n) of last  entry of 1-D real table */
      #define CONFIG_TABLE_2D_REAL_START   3   /* log2(n) of first entry of 2-D real table */
      #define CONFIG_TABLE_2D_REAL_END    14   /* log2(n) of last  entry of 2-D real table */
      #define CONFIG_TABLE_1D_CMPL_START   6   /* log2(n) of first entry of 1-D complex table */
      #define CONFIG_TABLE_1D_CMPL_END    27   /* log2(n) of last  entry of 1-D complex table */
      #define CONFIG_TABLE_2D_CMPL_START   2   /* log2(n) of first entry of 2-D complex table */
      #define CONFIG_TABLE_2D_CMPL_END    13   /* log2(n) of last  entry of 2-D complex table */

      static int mfftRectOffsetTable[] = 
             { 1, -1, -1, -1, 3, -1, -3, -2, -1, -2, -2, -1, -2, -1, -1, 0, -1, -1, -2, -1, -2, -1};

      static size_t fftStripeSize1DComplex[] = 
             { 6, 9, 9, 24, 10, 12, 4, 11, 5, 28, 16, 15, 15, 20, 28, 32, 32, 32, 24, 24, 24, 16};
      static size_t fftStripeSize2DComplex[] = 
             { 5, 28, 1, 4, 4, 12, 16, 8, 24, 24, 16, 8};
      static size_t fftStripeSize2DReal[] = 
             { 7, 32, 6, 4, 4, 16, 7, 32, 16, 16, 8, 28};
             
      #define MFFT_1D_COMPLEX_MIN_SIZE    15
      #define MFFT_2D_COMPLEX_MIN_SIZE    12
      #define MFFT_1D_REAL_MIN_SIZE       17
      #define MFFT_2D_REAL_MIN_SIZE       14

   #endif   /* ((FFT_DOUBLE_PREC == 1) && (FFT_SPLIT_COMPLEX == 0)) */


   #if   ((FFT_DOUBLE_PREC == 1) && (FFT_SPLIT_COMPLEX == 1))

      /* Double precision Split complex */

      #define CONFIG_TABLE_1D_REAL_START   7   /* log2(n) of first entry of 1-D real table */
      #define CONFIG_TABLE_1D_REAL_END    28   /* log2(n) of last  entry of 1-D real table */
      #define CONFIG_TABLE_2D_REAL_START   3   /* log2(n) of first entry of 2-D real table */
      #define CONFIG_TABLE_2D_REAL_END    14   /* log2(n) of last  entry of 2-D real table */
      #define CONFIG_TABLE_1D_CMPL_START   6   /* log2(n) of first entry of 1-D complex table */
      #define CONFIG_TABLE_1D_CMPL_END    27   /* log2(n) of last  entry of 1-D complex table */
      #define CONFIG_TABLE_2D_CMPL_START   2   /* log2(n) of first entry of 2-D complex table */
      #define CONFIG_TABLE_2D_CMPL_END    13   /* log2(n) of last  entry of 2-D complex table */

      static int mfftRectOffsetTable[] = 
             { 0, 0, 0, 2, 1, -1, -3, -2, -4, -1, -2, -1, -2, -4, -2, -2, -3, -2, -2, -1, -2, -2};

      static size_t fftStripeSize1DComplex[] = 
             { 12, 48, 64, 5, 64, 8, 40, 14, 14, 14, 12, 12, 15, 12, 64, 64, 56, 64, 48, 32, 8, 32};
      static size_t fftStripeSize2DComplex[] = 
             { 40, 48, 3, 10, 13, 56, 16, 4, 32, 24, 16, 8};
      static size_t fftStripeSize2DReal[] = 
             { 40, 48, 13, 64, 40, 56, 40, 32, 32, 24, 8, 56};
             
      #define MFFT_1D_COMPLEX_MIN_SIZE    17
      #define MFFT_2D_COMPLEX_MIN_SIZE    13
      #define MFFT_1D_REAL_MIN_SIZE       18
      #define MFFT_2D_REAL_MIN_SIZE       14

   #endif   /* ((FFT_DOUBLE_PREC == 1) && (FFT_SPLIT_COMPLEX == 1)) */


#elif   (FFT_PLATFORM == FFT_Xeon_8_32GB) 

#pragma mark --- 8-core Xeon with 32 GB RAM ---

/*
 * CPU                     : Intel(R) Xeon(R) CPU X5482 @ 3.20GHz
 * RAM                     : 32GB
 * Physical CPUs           : 8
 * Logical CPUs            : 8
 * L1 data cache size      : 32768
 * L2 cache size           : 6291456
 * L1 processors per cache : 1
 * L2 processors per cache : 2
 */
   #if   ((FFT_DOUBLE_PREC == 0) && (FFT_SPLIT_COMPLEX == 0))

      /* Single precision Interleaved complex */

      #define CONFIG_TABLE_2D_REAL_START   3   /* log2(n) of first entry of 2-D real table */
      #define CONFIG_TABLE_2D_REAL_END    16   /* log2(n) of last  entry of 2-D real table */
      #define CONFIG_TABLE_1D_CMPL_START   6   /* log2(n) of first entry of 1-D complex table */
      #define CONFIG_TABLE_1D_CMPL_END    31   /* log2(n) of last  entry of 1-D complex table */
      #define CONFIG_TABLE_2D_CMPL_START   2   /* log2(n) of first entry of 2-D complex table */
      #define CONFIG_TABLE_2D_CMPL_END    15   /* log2(n) of last  entry of 2-D complex table */

      static int mfftRectOffsetTable[] = 
             { -1, -1, -1, -2, 0, -3, -4, -4, 0, -2, -2, -1, -1, -2, -2, -1, -3, -3, -4, -3, -2, -1, -2, -1, -2, 0};

      static size_t fftStripeSize1DComplex[] = 
             { 3, 2, 11, 7, 5, 16, 16, 16, 15, 13, 4, 14, 4, 15, 15, 15, 13, 14, 15, 4, 32, 32, 32, 32, 40, 56};
      static size_t fftStripeSize2DComplex[] = 
             { 16, 7, 32, 2, 14, 9, 10, 4, 5, 32, 64, 32, 8, 56};
      static size_t fftStripeSize2DReal[] = 
             { 11, 16, 64, 64, 48, 24, 6, 2, 32, 64, 32, 8, 56, 56};

      #define MFFT_1D_COMPLEX_MIN_SIZE    15
      #define MFFT_2D_COMPLEX_MIN_SIZE    16
      #define MFFT_1D_REAL_MIN_SIZE       17
      #define MFFT_2D_REAL_MIN_SIZE       16

   #endif   /* ((FFT_DOUBLE_PREC == 0) && (FFT_SPLIT_COMPLEX == 0)) */

   #if   ((FFT_DOUBLE_PREC == 0) && (FFT_SPLIT_COMPLEX == 1))

      /* Single precision Split complex */

      #define CONFIG_TABLE_1D_REAL_START   7   /* log2(n) of first entry of 1-D real table */
      #define CONFIG_TABLE_1D_REAL_END    32   /* log2(n) of last  entry of 1-D real table */
      #define CONFIG_TABLE_2D_REAL_START   3   /* log2(n) of first entry of 2-D real table */
      #define CONFIG_TABLE_2D_REAL_END    16   /* log2(n) of last  entry of 2-D real table */
      #define CONFIG_TABLE_1D_CMPL_START   6   /* log2(n) of first entry of 1-D complex table */
      #define CONFIG_TABLE_1D_CMPL_END    31   /* log2(n) of last  entry of 1-D complex table */
      #define CONFIG_TABLE_2D_CMPL_START   2   /* log2(n) of first entry of 2-D complex table */
      #define CONFIG_TABLE_2D_CMPL_END    15   /* log2(n) of last  entry of 2-D complex table */

      static int mfftRectOffsetTable[] = 
             { -1, -1, -2, 1, 1, 0, 0, 1, -3, -2, -3, -4, -4, -2, -4, -4, -4, -4, -4, -4, -4, -4, -3, -2, -3, -2};

      static size_t fftStripeSize1DComplex[] = 
             { 13, 10, 3, 112, 64, 32, 112, 96, 112, 16, 80, 32, 48, 128, 48, 128, 96, 128, 128, 8, 80, 80, 48, 64, 64, 32};
      static size_t fftStripeSize2DComplex[] = 
             { 8, 2, 6, 8, 64, 16, 16, 16, 48, 48, 64, 32, 112, 112};
      static size_t fftStripeSize2DReal[] = 
             { 15, 12, 6, 96, 64, 16, 16, 32, 64, 64, 32, 112, 112, 48};

      #define MFFT_1D_COMPLEX_MIN_SIZE    16
      #define MFFT_2D_COMPLEX_MIN_SIZE    16
      #define MFFT_1D_REAL_MIN_SIZE       19
      #define MFFT_2D_REAL_MIN_SIZE       16

   #endif   /* ((FFT_DOUBLE_PREC == 0) && (FFT_SPLIT_COMPLEX == 1)) */

   #if   ((FFT_DOUBLE_PREC == 1) && (FFT_SPLIT_COMPLEX == 0))

      /* Double precision Interleaved complex */

      #define CONFIG_TABLE_1D_REAL_START   7   /* log2(n) of first entry of 1-D real table */
      #define CONFIG_TABLE_1D_REAL_END    31   /* log2(n) of last  entry of 1-D real table */
      #define CONFIG_TABLE_2D_REAL_START   3   /* log2(n) of first entry of 2-D real table */
      #define CONFIG_TABLE_2D_REAL_END    15   /* log2(n) of last  entry of 2-D real table */
      #define CONFIG_TABLE_1D_CMPL_START   6   /* log2(n) of first entry of 1-D complex table */
      #define CONFIG_TABLE_1D_CMPL_END    30   /* log2(n) of last  entry of 1-D complex table */
      #define CONFIG_TABLE_2D_CMPL_START   2   /* log2(n) of first entry of 2-D complex table */
      #define CONFIG_TABLE_2D_CMPL_END    14   /* log2(n) of last  entry of 2-D complex table */

      static int mfftRectOffsetTable[] = 
             { -1, -1, 2, 1, -3, -3, -4, -2, -3, -2, -2, -3, -2, -3, -3, -3, -3, -3, -3, -2, -2, -1, -2, -1, 0};

      static size_t fftStripeSize1DComplex[] = 
             { 6, 11, 10, 24, 20, 4, 16, 7, 10, 7, 13, 15, 9, 15, 15, 13, 14, 14, 15, 16, 32, 16, 32, 16, 28};
      static size_t fftStripeSize2DComplex[] = 
             { 7, 7, 12, 32, 28, 2, 2, 6, 16, 28, 32, 16, 4};
      static size_t fftStripeSize2DReal[] = 
             { 20, 2, 7, 15, 13, 2, 5, 13, 32, 32, 16, 4, 28};

      #define MFFT_1D_COMPLEX_MIN_SIZE    14
      #define MFFT_2D_COMPLEX_MIN_SIZE    13
      #define MFFT_1D_REAL_MIN_SIZE       16
      #define MFFT_2D_REAL_MIN_SIZE       14

   #endif   /* ((FFT_DOUBLE_PREC == 1) && (FFT_SPLIT_COMPLEX == 0)) */

   #if   ((FFT_DOUBLE_PREC == 1) && (FFT_SPLIT_COMPLEX == 1))

      /* Double precision Split complex */

      #define CONFIG_TABLE_1D_REAL_START   7   /* log2(n) of first entry of 1-D real table */
      #define CONFIG_TABLE_1D_REAL_END    31   /* log2(n) of last  entry of 1-D real table */
      #define CONFIG_TABLE_2D_REAL_START   3   /* log2(n) of first entry of 2-D real table */
      #define CONFIG_TABLE_2D_REAL_END    15   /* log2(n) of last  entry of 2-D real table */
      #define CONFIG_TABLE_1D_CMPL_START   6   /* log2(n) of first entry of 1-D complex table */
      #define CONFIG_TABLE_1D_CMPL_END    30   /* log2(n) of last  entry of 1-D complex table */
      #define CONFIG_TABLE_2D_CMPL_START   2   /* log2(n) of first entry of 2-D complex table */
      #define CONFIG_TABLE_2D_CMPL_END    14   /* log2(n) of last  entry of 2-D complex table */

      static int mfftRectOffsetTable[] = 
             { -1, -1, 0, 2, 3, -3, -4, -4, -4, -4, -3, 3, -3, -2, -4, -4, -4, -4, -2, -3, -3, -2, -3, -2, -2};

      static size_t fftStripeSize1DComplex[] = 
             { 56, 2, 16, 10, 64, 11, 9, 24, 5, 10, 12, 2, 12, 12, 15, 14, 14, 14, 56, 32, 32, 32, 64, 32, 24};
      /* recalculate */static size_t fftStripeSize2DComplex[] = 
             { 5, 15, 16, 8, 13, 40, 4, 4, 5, 3, 6, 8, 8};
      static size_t fftStripeSize2DReal[] = 
             { 14, 1, 14, 40, 10, 2, 4, 32, 32, 32, 2, 9, 12};
             
      #define MFFT_1D_COMPLEX_MIN_SIZE    15
      #define MFFT_2D_COMPLEX_MIN_SIZE    13
      #define MFFT_1D_REAL_MIN_SIZE       17
      #define MFFT_2D_REAL_MIN_SIZE       14

             
   #endif   /* ((FFT_DOUBLE_PREC == 1) && (FFT_SPLIT_COMPLEX == 1)) */

#elif   (FFT_PLATFORM == FFT_Other) 
/* 
 * Define a platform and make a table like those above. 
 */
#else
#error Please define FFT_PLATFORM.
#endif

#ifndef CONFIG_TABLE_1D_CMPL_START

#pragma mark --- Configuration stubs ---

/*
 * These stubs result in poor performance but they at least let you compile
 * on a platform other than those defined above. They are really intended to be
 * used as stubs when running mfftAutoCOnf on a new platform. 
 */
      #define CONFIG_TABLE_2D_REAL_START   4   /* log2(n) of first entry of 2-D real table */
      #define CONFIG_TABLE_2D_REAL_END     4   /* log2(n) of last  entry of 2-D real table */
      #define CONFIG_TABLE_1D_CMPL_START   4   /* log2(n) of first entry of 1-D complex table */
      #define CONFIG_TABLE_1D_CMPL_END     4   /* log2(n) of last  entry of 1-D complex table */
      #define CONFIG_TABLE_2D_CMPL_START   4   /* log2(n) of first entry of 2-D complex table */
      #define CONFIG_TABLE_2D_CMPL_END     4   /* log2(n) of last  entry of 2-D complex table */

      static int mfftRectOffsetTable[] = 
             { 0 };

      static size_t fftStripeSize1DComplex[] = 
             { FFT_SUBMATRIX_ATOM };
      static size_t fftStripeSize2DComplex[] = 
             { FFT_SUBMATRIX_ATOM };
      static size_t fftStripeSize2DReal[] = 
             { FFT_SUBMATRIX_ATOM };
#endif  /* CONFIG_TABLE_1D_REAL_START */

#ifndef MFFT_1D_REAL_MIN_SIZE
     /*
      * Stubs where min MatrixFFT sizes are not defined.
      */

      /* 
       * Min sizes where MatrixFFT performance exceeds that of vDSP.
       * The values specified are log2(total signal size).
       */
      #define MFFT_1D_REAL_MIN_SIZE        8
      #define MFFT_2D_REAL_MIN_SIZE        12
      #define MFFT_1D_COMPLEX_MIN_SIZE     8
      #define MFFT_2D_COMPLEX_MIN_SIZE     12
#endif /* MFFT_1D_REAL_MIN_SIZE */


/***
 *** End of machine-generated config tables
 ***/
 
#pragma mark ---- Infer rectangle dimensions from 1-D size ----

/*
 * Infer rectangle dimensions from 1-D size.
 * Static mfftRectOffset allows apps to specify offsets other than the 
 * currently configured size.
 * In no case will mfftRectOffset cause either nRow or nCol
 *    to be less than 1 or larger than nIn-1. 
 */
static int mfftRectOffset = 0;
static bool mfftRectOffsetSpecd = false;    // true when app has tweaked mfftRectOffset

void mfftMakeRectangle(
	unsigned nIn,		// log2(size)
	uint32_t optFlags,  // only MCF_HintTranspose used
	unsigned *nRow,		// log2(numRows)
	unsigned *nCol)		// log2(numCols)
{
	/* Baseline nRow calculation */
	unsigned nR = nIn >> 1;
	
    if((optFlags & MCF_HintTranspose) && ((nIn & 0x01) == 0)) {
        /*
         * Even signal and app wants to transpose: skip the rest
         * of this routine and given them a square matrix to maximize
         * performance of the transpose.
         */
        *nRow = *nCol = nR;
        return;
    }
    
    /* 
     * If app has specified an offset, use that, clamping between
	 * {1, nIN-1}.
     */
    if(mfftRectOffsetSpecd) {
		int inR = (int)nR + mfftRectOffset;
		int inIn = (int)nIn;
		if(inR < 1) {
			inR = 1;
		}
		else if(inR > (inIn - 1)) {
			inR = inIn - 1;
		}
		nR = (unsigned)inR;
    }
    else {
        /* use platform-specific offset */
        int offset = 0;
        if(nIn < CONFIG_TABLE_1D_CMPL_START) {
            /* before start of table, small signal, no offset */
            offset = 0;
        }
        else if(nIn > CONFIG_TABLE_1D_CMPL_END) {
            /* past end of table, use last entry */
            unsigned lastDex = CONFIG_TABLE_1D_CMPL_END - CONFIG_TABLE_1D_CMPL_START;
            offset = mfftRectOffsetTable[lastDex];
        }
        else {
            /* use configured offset */
            offset = mfftRectOffsetTable[nIn - CONFIG_TABLE_1D_CMPL_START];
        }
        nR += offset;
	}
    
	*nRow = nR;
	*nCol = nIn - nR;
}

#pragma mark --- Obtain column stripe size ---


/*
 * When these are non-zero, app has specified column stripe size via 
 * mfftSetColumnStripeSize(). One for real, one for complex. Note
 * we don't need four of these because an app never has to specify 
 * a 1-dim and a 2-dim value at the same time. The real and complex
 * are however used together, in building the tables for 1-D real. 
 * Sizes are in complex elements.
 */
static size_t mfftColStripeSizeReal = 0;
static size_t mfftColStripeSizeComplex = 0;

/* 
 * Obtain the size of a column stripe, in complex elements, 
 * given FFT type and log2 of either signal size (for 1-D) 
 * or numRows (for 2-D).
 */
size_t mfftColumnStripeSize(
    unsigned    log2n,              // log2(numRows) or log2(N)
    bool        isReal,
    unsigned    numDims,
    uint32_t    l2CachePerEngine)   // currently unused
{
    /* first handle app-specified overrides */
    if(isReal) {
        if(mfftColStripeSizeReal != 0) {
            return mfftColStripeSizeReal;
        }
    }
    else if(mfftColStripeSizeComplex != 0) {
        return mfftColStripeSizeComplex;
    }
    
    const size_t *stripeSizes = NULL;
    unsigned tableMin = 0;
    unsigned tableMax = 0;
    
    if(isReal) {
        if(numDims == 1) {
            /* This op doesn't use stripes */
            return 0;
        }
        else {
            stripeSizes = fftStripeSize2DReal;
            tableMin = CONFIG_TABLE_2D_REAL_START;
            tableMax = CONFIG_TABLE_2D_REAL_END;
        }
    }
    else {
        if(numDims == 1) {
            stripeSizes = fftStripeSize1DComplex;
            tableMin = CONFIG_TABLE_1D_CMPL_START;
            tableMax = CONFIG_TABLE_1D_CMPL_END;
        }
        else {
            stripeSizes = fftStripeSize2DComplex;
            tableMin = CONFIG_TABLE_2D_CMPL_START;
            tableMax = CONFIG_TABLE_2D_CMPL_END;
        }
    }
    
    size_t stripeSize = 0;
    if(log2n < tableMin) {
        /* before start of table, use first entry */
        stripeSize = stripeSizes[0];
    }
    else if(log2n > tableMax) {
        /* past end of table, use last entry */
        stripeSize = stripeSizes[tableMax - tableMin];
    }
    else {
        /* use configured stripe size */
        stripeSize = stripeSizes[log2n - tableMin];
    }
    return stripeSize;
}

#pragma mark --- Determine if MatrixFFT should be bypassed in favor of vDSP ---

/*
 * App-tweakable override.
 */
static MFFT_ForceVdsp mfftForceVdsp = MF_Default;
                                            
/*
 * Determine if it's best to fall back and use raw vDSP calls for
 * FFT of specified type and size. For 2-D ops, log2n is the log
 * of the total signal size (i.e. log2n = log2(numRows * numCols).
 * Returns true if vDSP calls should be used.
 */
bool mfftShouldUseVdsp(
    unsigned    log2n,               // log2(total signal size)
    bool        isReal,
    unsigned    numDims)
{
    switch(mfftForceVdsp) {
        case MF_Default:
            break;
        case MF_ForceVdsp:
            return true;
        case MF_ForceMfft:
            return false;
    }
    
    unsigned minSize = 0;
    if(isReal) {
        if(numDims > 1) {
            minSize = MFFT_2D_REAL_MIN_SIZE;
        }
        else {
            minSize = MFFT_1D_REAL_MIN_SIZE;
        }
    }   
    else {
        if(numDims > 1) {
            minSize = MFFT_2D_COMPLEX_MIN_SIZE;
        }
        else {
            minSize = MFFT_1D_COMPLEX_MIN_SIZE;
        }
    }
    if(log2n < minSize) {
        return true;
    }
    else {
        return false;
    }
}

#pragma mark --- Configuration tweakers ---

/*
 * Routines to modify the normal config parameters at runtime.
 * These are used by the tools which create our config tables.
 */
 

/*
 * Specify signed offset to the normal derivation of 2-D coordinates from
 * a 1-D size. Also used to remove previous specification (by passing
 * 'false' to enableOffset).
 */
void mfftSetRectangleOffset(
	int     rectOffset,
    bool    enableOffset)
{
    if(enableOffset) {
        mfftRectOffset = rectOffset;
        mfftRectOffsetSpecd = true;
    }
    else {
        mfftRectOffsetSpecd = false;
    }
}

/* 
 * Specify column stripe size in complex elements.
 * Specify 0 to revert to using built-in tables.
 * Note that caller can spoecify sizes that are not aligned to
 * submatrices, because some platforms and configurations
 * e.g. Nehalem, double precision, split complex) work better
 * without matrix-aligned columns. 
 */
void mfftSetColumnStripeSize(
    bool    isReal,
    size_t  colStripeSize)
{
    if(isReal) {
        mfftColStripeSizeReal = colStripeSize;
    }
    else {
        mfftColStripeSizeComplex = colStripeSize;
    }
}

/* 
 * Force vDSP or MatrixFFT in subsequent calls to mfftShouldUseVdsp.
 */
extern void mfftSetForceVdsp(
    MFFT_ForceVdsp  forceVdsp)
{
    mfftForceVdsp = forceVdsp;
}

