                             Configuring MatrixFFT
                             Last Update May 5 2011
                           
                           
This document contains information needed to configure the MatrixFFT package for a
specific application and platform. See the README files at the top-level directory and 
in libMatrixFFT/ subdirectory for general information on the MatrixFFT package.

First, note that this library is intended to be used on Intel Macs. It runs on PPC-based
Macs, but there is a fair amount of Intel-specific optimization which cannot be used on 
PPCs, and there is no corresponding PPC-specific optimization. Performance on PPC is 
very poor, not to mention the fact the the sizes of the low-level FFTs available on 
the PPC are very limited, thus in turn limiting the sizes of MatrixFFT operations. 

Also, note that performing FFTs on signals larger than approximately 2^31 *bytes* (e.g. 
2^27 double-precision complex elements) must be done with 64-bit binaries. However, 
at least on Mac OS X versions 10.4 and 10.5, the low-level FFTs implemented in 
Accelerate.framework and used by MatrixFFT are significantly slower in the 64-bit
versions than the 32-bit versions, by a factor of 2x or more. Thus the 64-bit build
of MatrixFFT runs considerably slower than the 32-bit build for the same signal
size for versions of Max OS X prior to 10.6. You should only use 64-bit builds when 
necessary (due to large signal sizes) or when running Mac OS X 10.6. 


Application-specific configuration
----------------------------------

There are two configuration constants that you must define which tailor the MatrixFFT
package to application-specific needs. These are both #defined in 
libMatrixFFT/MatrixFFTConfig.h; you can also define them at compile time via the -D
compiler directive. These flags are as follows:

  FFT_DOUBLE_PREC - To avoid a large set of mostly duplicated code, the precision
                    (float or double) of the MatrixFFT implementation is determined 
                    at compile time by this flag. 
  FFT_SPLIT_COMPLEX - Determines the format of complex data used in this library.
                    "Split format", the native format used by Accelerate.framework
                    based FFTs, stores the real and imaginary components of complex
                    data in separate, parallel arrays. "Interleaved format" stores
                    the real and imaginary components sequentially, together in 
                    the same array. On most Intel hardware, interleaved complex
                    format results in better performance for most signals which can
                    be processed with 32-bit binaries, even though this requires 
                    "shuffling" data to and from Accelerate's native split format
                    when low-level FFTs are performed. For large signals (of
                    2^30 elements or more) this performance increase is less
                    pronounced and in some cases eliminated. 


Platform-specific configuration
-------------------------------

There is a set of tables which are used by the MatrixFFT library at runtime and which 
can have a significant effect on the performance of the library. One table defines the
proportions of the rectangles into which 1-D complex FFTs are decomposed. Other tables
define "column stripe" sizes which are used to perform specific transposition operations. 
All of these tables are highly dependent on the hardware on which the library is running, 
specifically on the number of processors, the sizes of the various levels of memory cache,
and to some extent on the amount of RAM present. 

These platform-specific configuration parameters are generated by the mfftAutoConf program,
the output of which is a small snippet of 'C' code which is manually copied and pasted into 
a configuration file, libMatrixFFT/src/fftPlatformConf.cpp. 

When porting MatrixFFT to a new platform, you have several options for dealing with this
platform-specific configuration info, shown here in decreasing order of preference:

1. Generate new configuration data for your platform and application; add this new
   configuration data to fftPlatformConf.cpp and recompile. 
   
2. Use platform-specific configuration data already present in fftPlatformConf.cpp, for
   a platform similar to yours. Try to find an existing configuration that matches your
   platform's number of processors and cache sizes (in that order). 
   
3. Take a default case, which is in effect *no* platform-specific configuration data.
   This performs very poorly and is not recommended, but will allow you to compile the
   library for a newly defined platform. 
   
   
Generating new configuration data
---------------------------------

First, note that the mfftAutoConf program generates configuration data for the current
hardware platform, for the currently defined application-specific configuration (i.e. 
the current FFT_DOUBLE_PREC and FFT_SPLIT_COMPLEX). If you need only one of the four 
possible application-specific configurations then you only need to run mfftAutoConf 
once. For a given platform, mfftAutoConf needs to be run a maximum of four times, one 
for each application-specific configuration.

To generate new configuration data:

1. Define a new FFT_PLATFORM constant in libMatrixFFT/src/fftPlatformConf.h. See the existing
   constants, e.g. FFT_Xeon_8_32GB and FFT_Nehalem_8_32GB, for examples. Add a new #define
   to the end of this list. Let's say you add a new platform FFT_MyCPU_8_16GB:
   
       #define FFT_MyCPU_8_16GB     4    /* MyCPU, 8 cores, 16 GB of main memory */


2. #define FFT_PLATFORM to be equal to your newly defined platform.

       #define FFT_PLATFORM         FFT_MyCPU_8_16GB
       
   Note you can also perform this step at compile time via e.g. -D FFT_PLATFORM=FFT_MyCPU_8_16GB.

3. Edit libMatrixFFT/src/fftPlatformConf.cpp. Find the end of the existing tables, which 
   currently looks like this:
   
       #elif   (FFT_PLATFORM == FFT_Other) 
       /* 
        * Define a platform and make a table like those above. 
        */
       #else
       #error Please define FFT_PLATFORM.
       #endif

   Replace FFT_Other with your new platform name::
   
       #elif   (FFT_PLATFORM == FFT_MyCPU_8_16GB) 
       /* 
        * Your new configuration data will go here. 
        */
       #else
       #error Please define FFT_PLATFORM.
       #endif
   
4. Make sure the application-specific configuration constants in MatrixFFTConfig.h are
   #defined as you want them to be. Recompile the MatrixFFT project, target "World", 
   build configuration as appropriate (it should NOT be any of the Debug configurations).
   
5. Run the mfftAutoConf program with no arguments. 

   For systems with a lot of memory this run can take many hours; a 32 GB machine results
   in a run of at least 6 hours. (See "mfftAutoConf options", below, for more info.)
   
   While mfftAutoConf is running it will periodically print out some status indicating 
   what it's working on:
   
        % mfftAutoConf 

        Generating configuration tables for the following maximum FFT sizes:
        1-D complex : 2^27 elements
        1-D real    : 2^28 elements
        2-D complex : 2^13 rows
        2-D real    : 2^14 rows

        +++ timing 1D complex N=2^6
        +++ timing 1D complex N=2^7
        +++ timing 1D complex N=2^8
        +++ timing 1D complex N=2^9
        ...etc.
        +++ timing 2D complex numRows=2^2
        +++ timing 2D complex numRows=2^3
        +++ timing 2D complex numRows=2^4
        +++ timing 2D complex numRows=2^5
        ...etc.
        
6. When mfftAutoConf is done, it prints out C code that looks like this:
   
       #if   ((FFT_DOUBLE_PREC == 1) && (FFT_SPLIT_COMPLEX == 1))

          /* Double precision Split complex */

          #define CONFIG_TABLE_2D_REAL_START   3   /* log2(n) of first entry of 2-D real table */
          #define CONFIG_TABLE_2D_REAL_END     8   /* log2(n) of last  entry of 2-D real table */
          #define CONFIG_TABLE_1D_CMPL_START   6   /* log2(n) of first entry of 1-D complex table */
          #define CONFIG_TABLE_1D_CMPL_END    15   /* log2(n) of last  entry of 1-D complex table */
          #define CONFIG_TABLE_2D_CMPL_START   2   /* log2(n) of first entry of 2-D complex table */
          #define CONFIG_TABLE_2D_CMPL_END     7   /* log2(n) of last  entry of 2-D complex table */

          static int mfftRectOffsetTable[] = 
                 { 0, 1, 0, 1, -3, -2, -3, -3, -3, -3};

          static size_t fftStripeSize1DComplex[] = 
                 { 32, 10, 5, 14, 40, 24, 16, 8, 8, 16};
          static size_t fftStripeSize2DComplex[] = 
                 { 11, 12, 56, 13, 8, 1};
          static size_t fftStripeSize2DReal[] = 
                 { 11, 40, 24, 2, 2, 1};
       #endif   /* ((FFT_DOUBLE_PREC == 1) && (FFT_SPLIT_COMPLEX == 1)) */

7. Copy & paste everything from the #if to the #endif, inclusive, into the new place in 
   libMatrixFFT/src/fftPlatformConf.cpp reserved for your configuration:
   

       #elif   (FFT_PLATFORM == FFT_MyCPU_8_16GB)
           #if   ((FFT_DOUBLE_PREC == 1) && (FFT_SPLIT_COMPLEX == 1))

              /* Double precision Split complex */

              #define CONFIG_TABLE_1D_REAL_START   7   /* log2(n) of first entry of 1-D real table */
              ...etc.
              static size_t fftStripeSize2DReal[] = 
                    { 11, 40, 24, 2, 2, 1};
           #endif   /* ((FFT_DOUBLE_PREC == 1) && (FFT_SPLIT_COMPLEX == 1)) */
       #else
       #error Please define FFT_PLATFORM.
       #endif

8. Recompile the MatrixFFT package one more time. 


mfftAutoConf options
--------------------

Run the program with the "-h" command line argument for usage:

        % mfftAutoConf -h
        usage: mfftAutoConf [options]
        Options:
          -n minSize      -- minimum 1D real FFT size; K, M, 2^n OK; default 128
          -x maxSize      -- maximum 1D real FFT size; K, M, 2^n OK; default per HW config
          -q              -- quick (Small loop counts and sizes)
          -v              -- verbose
          -V              -- really verbose
          -1              -- (one) 1-dimension only
          -2              -- 2-dimension only
          -c              -- complex only
          -r              -- real only
          -i              -- just print CPU/memory info as C comment

One common option is the "-i" option, which displays information about the current platform
in the form of a "C" comment, appropriate for including in the platform-specific configuration
data you add to fftPlatformConf.cpp:

        % mfftAutoConf -i
        /*
         * CPU                     : Intel(R) Xeon(R) CPU 5150 @ 2.66GHz
         * RAM                     : 4GB
         * Physical CPUs           : 4
         * Logical  CPUs           : 4
         * L1 data cache size      : 32768
         * L2 cache size           : 4194304
         * L1 processors per cache : 1
         * L2 processors per cache : 2
         */

This is also useful for trying to find a match between one of the existing configutations and 
yoru platform.

The other most common option is the "-x maxSize" argument. By default, mfftAutoConf generates
configuration data for FFTs up to the largest size which can fit in main memory on the current
platform. When a large amount of memory is installed, this can take a long time, i.e. overnight
for a 32 GB machine. If your application is not going to be performing FFTs that large, you can
tell mfftAutoConf to limit its work to an arbitrary upper limit. This limit is the maximum number
of elements in a 1-D real FFT. The max size can be specified as an integer, with a "k", "m", 
or "g" suffixes (either case), or as a power of two like 2^20:

         % mfftAutoConf -x 1m         -- max size 2^20 elements
         % mfftAutoConf -x 512K       -- max size 2^19 elements
         % mfftAutoConf -x 1g         -- max size 2^30 elements
         % mfftAutoConf -x 2^24
         
         
 